# 不同的 count 用法
## 概述

在 `select count(?) from t` 这样的查询语句里面，

- `count(*)`
- `count(主键 id)`
- `count(字段)` 
-  `count(1)`

等不同用法的性能，有哪些差别（基于 InnoDB 引擎）
## 分析

`count()` 是一个聚合函数，对于返回的结果集，一行行地判断，**如果 count 函数的参数不是 NULL**，累计值就加 1，否则不加。最后返回累计值。

所以：
- `count(*)`、`count(主键 id)` 和 `count(1)` 都表示返回满足条件的结果集的总行数；
- `count(字段)`，则表示返回满足条件的数据行里面，参数「字段」不为 NULL 的总个数。

至于分析性能差别的时候，你可以记住这么几个原则：

1. server 层要什么就给什么；

1. InnoDB 只给必要的值；

1. 现在的优化器只优化了 `count(*)` 的语义为「取行数」，其他「显而易见」的优化并没有做。

这是什么意思呢？接下来，我们就一个个地来看看。

对于 `count(主键 id)` 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。

对于 `count(1)` 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字 `1` 进去，判断是不可能为空的，按行累加。

单看这两个用法的差别的话，你能对比出来，`count(1)` 执行得要比 `count(主键 id)` 快。因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。

对于 `count(字段)` 来说：

如果这个「字段」是定义为 `not null` 的话，一行行地从记录里面读出这个字段，判断不能为 `null`，按行累加；

如果这个「字段」定义允许为 `null`，那么执行的时候，判断到有可能是 `null`，还要把值取出来再判断一下，不是 `null` 才累加。

也就是前面的第一条原则，server 层要什么字段，InnoDB 就返回什么字段。

但是 `count(*)` 是例外，并不会把全部字段取出来，而是专门做了优化，不取值。count(\*) 肯定不是 null，按行累加。

## 结论
按照效率排序：`count(字段)` < `count(主键 id)` < `count(1)` ≈ `count(*)`

所以尽量使用 `count(*)`。